// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collectlogfiles

import (
	"archive/tar"
	"compress/gzip"
	"crypto/md5"
	"encoding/hex"
	"io"
	"os"
	"path/filepath"
	"sort"
	"testing"

	"github.com/google/go-cmp/cmp"
)

const (
	// Generated by concatenating all strings in logFileNames list in collectlogfiles package
	// with "reproxy_log.txt" (representing the contents of the file at RBE_log_path
	// environment variable) and computing the md5sum of the concatenated string.
	wantSum = "ac27acdab21f9abeed44e8612d63226f"

	reproxyLog = "reproxy_log.txt"
)

func TestCreateLogsArchive(t *testing.T) {
	// Setup fake directory and create fake log files inside it.
	tmpDir := t.TempDir()
	testFiles := []string{
		"reproxy.INFO",
		"reproxy.hostname.username.log.INFO.20230921-153342.97022",
		"reproxy.exe.INFO",
		"scandeps_server.INFO",
		"scandeps_server.exe.INFO",
		"reproxy.WARNING",
		"reproxy.exe.WARNING",
		"reproxy.ERROR",
		"reproxy.exe.ERROR",
		"reproxy_log.txt",
		"reproxy_2023-09-21_15_33_47.rrpl",
		"reproxy_2023-09-21_15_33_47.rpl",
	}

	var logPath string
	for _, fname := range testFiles {
		p := filepath.Join(tmpDir, fname)
		if err := os.WriteFile(p, []byte(fname), 0644); err != nil {
			t.Fatalf("Unable to write %s to file %v: %v", fname, p, err)
		}
		if fname != reproxyLog {
			continue
		}
		logPath = "text://" + p
	}

	logFile, err := os.CreateTemp("", "reclient-log-collection-test-*.tar.gz")
	if err != nil {
		t.Fatalf("Failed to create temp log file: %v", err)
	}
	logFile.Close()
	logFilename := logFile.Name()
	defer os.RemoveAll(logFilename)
	if err := CreateLogsArchive(logFilename, []string{tmpDir}, logPath); err != nil {
		t.Errorf("CreateLogsArchive(%v) failed: %v", logFilename, err)
	}

	gotFiles := fnamesFromArchive(t, logFilename)
	wantFiles := testFiles

	sort.Strings(gotFiles)
	sort.Strings(wantFiles)

	if diff := cmp.Diff(wantFiles, gotFiles); diff != "" {
		t.Errorf("Got wrong log files in tar.gz\n (-want +got): %v", diff)
	}

	gotSum := md5sum(t, logFilename)
	if wantSum != gotSum {
		t.Fatalf("Digest mismatch in created log file package, got %v, want %v", gotSum, wantSum)
	}
}

func fnamesFromArchive(t *testing.T, logFile string) (files []string) {
	f, err := os.Open(logFile)
	if err != nil {
		t.Fatalf("Unable to open logfile %v: %v", logFile, err)
	}
	defer f.Close()
	gz, err := gzip.NewReader(f)
	if err != nil {
		t.Fatalf("Unable to read created logfile %v: %v", logFile, err)
	}
	defer gz.Close()
	tr := tar.NewReader(gz)

	for {
		th, err := tr.Next()
		if err == io.EOF {
			return
		}
		if err != nil {
			t.Errorf("Error when reading tar.gz file: %v", err)
			return
		}
		files = append(files, filepath.Base(th.Name))
	}
}

// md5sum computes the md5sum of the contents of the files in given .tar.gz logfile.
func md5sum(t *testing.T, logFile string) string {
	t.Helper()

	// The created gzip file is non-deterministic, so gunzip / untar it back and then
	// compute the digest.
	f, err := os.Open(logFile)
	if err != nil {
		t.Fatalf("Unable to open logfile %v: %v", logFile, err)
	}
	defer f.Close()
	gz, err := gzip.NewReader(f)
	if err != nil {
		t.Fatalf("Unable to read created logfile %v: %v", logFile, err)
	}
	defer gz.Close()
	tr := tar.NewReader(gz)

	h := md5.New()
	for {
		th, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Errorf("Error when reading tar.gz file: %v", err)
			break
		}
		if _, err := io.Copy(h, tr); err != nil {
			t.Errorf("Unable to read %v in .tar.gz file: %v", th.Name, err)
		}
	}
	return hex.EncodeToString(h.Sum(nil))
}
